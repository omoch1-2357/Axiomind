//! Integration tests for rustdoc validation (Task 3.2)
//!
//! This test suite validates:
//! - search-index.js generation
//! - Cross-crate documentation links
//! - Documentation structure and navigation

use std::fs;
use std::path::PathBuf;
use std::process::Command;

/// Helper to get the project root directory
fn project_root() -> PathBuf {
    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    PathBuf::from(manifest_dir)
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .to_path_buf()
}

/// Test 1: Verify search-index.js is generated by cargo doc
#[test]
fn test_search_index_generation() {
    let root = project_root();
    let target_doc = root.join("target").join("doc");

    // Build documentation
    let output = Command::new("cargo")
        .arg("doc")
        .arg("--workspace")
        .arg("--no-deps")
        .current_dir(&root)
        .output()
        .expect("Failed to run cargo doc");

    assert!(
        output.status.success(),
        "cargo doc failed: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Verify search-index.js exists in target/doc/
    let search_index = target_doc.join("search-index.js");
    assert!(
        search_index.exists(),
        "search-index.js not found at {:?}",
        search_index
    );

    // Verify search-index.js is not empty
    let content = fs::read_to_string(&search_index).expect("Failed to read search-index.js");
    assert!(!content.is_empty(), "search-index.js is empty");

    // Verify search-index.js contains references to our crates
    assert!(
        content.contains("axm_engine"),
        "search-index.js does not contain axm_engine"
    );
    assert!(
        content.contains("axm_cli"),
        "search-index.js does not contain axm_cli"
    );
    assert!(
        content.contains("axm_web"),
        "search-index.js does not contain axm_web"
    );
}

/// Test 2: Verify cross-crate documentation links are resolved correctly
#[test]
fn test_cross_crate_links() {
    let root = project_root();

    // Build documentation with link checking enabled
    let output = Command::new("cargo")
        .arg("rustdoc")
        .arg("-p")
        .arg("axm_cli")
        .arg("--lib")
        .arg("--")
        .arg("-D")
        .arg("warnings")
        .current_dir(&root)
        .output()
        .expect("Failed to run cargo rustdoc");

    // If there are broken links, cargo rustdoc will fail
    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        panic!(
            "Cross-crate link validation failed for axm_cli:\n{}",
            stderr
        );
    }

    // Verify axm_web also has no broken links
    let output = Command::new("cargo")
        .arg("rustdoc")
        .arg("-p")
        .arg("axm_web")
        .arg("--lib")
        .arg("--")
        .arg("-D")
        .arg("warnings")
        .current_dir(&root)
        .output()
        .expect("Failed to run cargo rustdoc");

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        panic!(
            "Cross-crate link validation failed for axm_web:\n{}",
            stderr
        );
    }
}

/// Test 3: Verify documentation structure and navigation files
#[test]
fn test_documentation_structure() {
    let root = project_root();
    let target_doc = root.join("target").join("doc");

    // Build documentation
    let output = Command::new("cargo")
        .arg("doc")
        .arg("--workspace")
        .arg("--no-deps")
        .current_dir(&root)
        .output()
        .expect("Failed to run cargo doc");

    assert!(
        output.status.success(),
        "cargo doc failed: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Verify each crate has an index.html
    let crates = vec!["axm_engine", "axm_cli", "axm_web"];
    for crate_name in &crates {
        let crate_index = target_doc.join(crate_name).join("index.html");
        assert!(
            crate_index.exists(),
            "index.html not found for {} at {:?}",
            crate_name,
            crate_index
        );

        // Verify index.html is not empty
        let content = fs::read_to_string(&crate_index)
            .unwrap_or_else(|_| panic!("Failed to read index.html for {}", crate_name));
        assert!(
            !content.is_empty(),
            "index.html for {} is empty",
            crate_name
        );
    }

    // Verify rustdoc standard files exist
    let required_files = vec!["search-index.js", "settings.html", "help.html"];

    for file in &required_files {
        let file_path = target_doc.join(file);
        assert!(
            file_path.exists(),
            "Required file {} not found at {:?}",
            file,
            file_path
        );
    }
}

/// Test 4: Verify custom index.html is generated correctly
#[test]
fn test_custom_index_generation() {
    let root = project_root();
    let target_doc = root.join("target").join("doc");

    // Build documentation
    Command::new("cargo")
        .arg("doc")
        .arg("--workspace")
        .arg("--no-deps")
        .current_dir(&root)
        .output()
        .expect("Failed to run cargo doc");

    // Run generate-doc-index.sh script
    let script_path = root.join("scripts").join("generate-doc-index.sh");

    // Try to find bash executable on Windows
    #[cfg(windows)]
    let bash_cmd = {
        // Try common locations for Git Bash
        let possible_paths = [
            "C:\\Program Files\\Git\\bin\\bash.exe",
            "C:\\Program Files (x86)\\Git\\bin\\bash.exe",
            "bash", // Will work if Git Bash is in PATH
        ];

        possible_paths
            .iter()
            .find(|path| Command::new(path).arg("--version").output().is_ok())
            .map(|s| s.to_string())
    };

    #[cfg(unix)]
    let bash_cmd = Some("bash".to_string());

    // Skip test if bash is not available on Windows
    #[cfg(windows)]
    if bash_cmd.is_none() {
        eprintln!("Skipping test_custom_index_generation: bash not found on Windows");
        eprintln!("Install Git Bash or add bash to PATH to run this test");
        return;
    }

    let output = Command::new(bash_cmd.unwrap())
        .arg(&script_path)
        .current_dir(&root)
        .output()
        .expect("Failed to run generate-doc-index.sh");

    if !output.status.success() {
        eprintln!("Script stderr: {}", String::from_utf8_lossy(&output.stderr));
        eprintln!("Script stdout: {}", String::from_utf8_lossy(&output.stdout));
        panic!(
            "generate-doc-index.sh failed with exit code: {:?}",
            output.status.code()
        );
    }

    // Verify custom index.html exists
    let index_html = target_doc.join("index.html");
    assert!(
        index_html.exists(),
        "Custom index.html not found at {:?}",
        index_html
    );

    // Verify custom index.html contains links to all crates
    let content = fs::read_to_string(&index_html).expect("Failed to read custom index.html");

    // Check which crates were actually built
    let expected_crates = vec!["axm_engine", "axm_cli", "axm_web"];
    let mut built_crates = Vec::new();

    for crate_name in &expected_crates {
        let crate_dir = target_doc.join(crate_name);
        if crate_dir.exists() {
            built_crates.push(*crate_name);
        }
    }

    // Verify links for all built crates exist in index.html
    for crate_name in &built_crates {
        let link = format!("{}/index.html", crate_name);
        assert!(
            content.contains(&link),
            "Custom index.html does not contain link to {} (crate was built at {:?})",
            crate_name,
            target_doc.join(crate_name)
        );
    }

    // Ensure at least axm_engine and axm_cli are built (axm_web depends on warp which is optional)
    assert!(
        built_crates.contains(&"axm_engine"),
        "axm_engine should be built"
    );
    assert!(built_crates.contains(&"axm_cli"), "axm_cli should be built");

    // Verify index.html contains project title
    assert!(
        content.contains("Axiomind"),
        "Custom index.html does not contain project title"
    );
}

/// Test 5: Verify cross-crate link examples in documentation
#[test]
fn test_cross_crate_link_examples() {
    let root = project_root();
    let target_doc = root.join("target").join("doc");

    // Build documentation
    Command::new("cargo")
        .arg("doc")
        .arg("--workspace")
        .arg("--no-deps")
        .current_dir(&root)
        .output()
        .expect("Failed to run cargo doc");

    // Read axm_cli documentation to check for links to axm_engine types
    let cli_lib_path = target_doc.join("axm_cli").join("index.html");

    if cli_lib_path.exists() {
        let content = fs::read_to_string(&cli_lib_path).expect("Failed to read axm_cli index.html");

        // Look for references to axm_engine types in the HTML
        // rustdoc generates links like: href="../axm_engine/struct.Card.html"
        // This is a smoke test to ensure cross-crate linking infrastructure works

        // Note: We can't assert specific links exist because they depend on
        // what documentation comments we've added, but we can verify the
        // general structure supports cross-linking
        assert!(
            content.contains("axm_cli"),
            "CLI documentation should reference its own crate name"
        );
    }
}
