//! Integration tests for rustdoc validation (Task 3.2)
//!
//! This test suite validates:
//! - search-index.js generation
//! - Cross-crate documentation links
//! - Documentation structure and navigation

use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

/// Helper to get the project root directory
fn project_root() -> PathBuf {
    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    PathBuf::from(manifest_dir)
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .to_path_buf()
}

#[derive(Debug, Clone)]
enum SearchIndexLocation {
    Legacy(PathBuf),
    Split { dir: PathBuf, root_js: PathBuf },
}

impl SearchIndexLocation {
    fn primary_path(&self) -> &Path {
        match self {
            SearchIndexLocation::Legacy(path) => path.as_path(),
            SearchIndexLocation::Split { root_js, .. } => root_js.as_path(),
        }
    }

    fn primary_content(&self) -> Option<String> {
        fs::read_to_string(self.primary_path()).ok()
    }

    fn combined_texts(&self) -> Vec<String> {
        let mut texts = Vec::new();

        if let Some(primary) = self.primary_content() {
            texts.push(primary);
        }

        if let SearchIndexLocation::Split { dir, .. } = self {
            let crate_dir = dir.join("crateNames");
            if let Ok(entries) = fs::read_dir(&crate_dir) {
                for entry in entries.flatten() {
                    if entry.file_type().map(|ft| ft.is_file()).unwrap_or(false) {
                        if let Ok(content) = fs::read_to_string(entry.path()) {
                            texts.push(content);
                        }
                    }
                }
            }
        }

        texts
    }

    fn contains_crate(&self, crate_name: &str) -> bool {
        self.combined_texts()
            .iter()
            .any(|content| content.contains(crate_name))
    }
}

fn find_search_index_assets(target_doc: &Path) -> Option<SearchIndexLocation> {
    let legacy = target_doc.join("search-index.js");
    if legacy.exists() {
        return Some(SearchIndexLocation::Legacy(legacy));
    }

    for dir_name in ["search.index", "search-index"] {
        let dir = target_doc.join(dir_name);
        let root_js = dir.join("root.js");
        if dir.is_dir() && root_js.exists() {
            return Some(SearchIndexLocation::Split { dir, root_js });
        }
    }

    None
}

/// Test 1: Verify search-index.js is generated by cargo doc
#[test]
fn test_search_index_generation() {
    let root = project_root();
    let target_doc = root.join("target").join("doc");

    // Build documentation
    let output = Command::new("cargo")
        .arg("doc")
        .arg("--workspace")
        .arg("--no-deps")
        .current_dir(&root)
        .output()
        .expect("Failed to run cargo doc");

    assert!(
        output.status.success(),
        "cargo doc failed: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Verify search-index.js exists in target/doc/
    let search_assets = find_search_index_assets(&target_doc).expect(
        "Rustdoc search index assets not found (expected search-index.js or search.index/root.js)",
    );

    let texts = search_assets.combined_texts();
    assert!(
        !texts.is_empty(),
        "Rustdoc search index assets were located but no readable content was found"
    );

    for text in &texts {
        assert!(
            !text.trim().is_empty(),
            "Rustdoc search index content should not be empty"
        );
    }

    for crate_name in ["axm_engine", "axm_cli", "axm_web"] {
        assert!(
            texts.iter().any(|content| content.contains(crate_name)),
            "Rustdoc search index content did not reference crate {crate_name}"
        );
    }
}

/// Test 2: Verify cross-crate documentation links are resolved correctly
#[test]
fn test_cross_crate_links() {
    let root = project_root();

    // Build documentation with link checking enabled
    let output = Command::new("cargo")
        .arg("rustdoc")
        .arg("-p")
        .arg("axm_cli")
        .arg("--lib")
        .arg("--")
        .arg("-D")
        .arg("warnings")
        .current_dir(&root)
        .output()
        .expect("Failed to run cargo rustdoc");

    // If there are broken links, cargo rustdoc will fail
    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        panic!(
            "Cross-crate link validation failed for axm_cli:\n{}",
            stderr
        );
    }

    // Verify axm_web also has no broken links
    let output = Command::new("cargo")
        .arg("rustdoc")
        .arg("-p")
        .arg("axm_web")
        .arg("--lib")
        .arg("--")
        .arg("-D")
        .arg("warnings")
        .current_dir(&root)
        .output()
        .expect("Failed to run cargo rustdoc");

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        panic!(
            "Cross-crate link validation failed for axm_web:\n{}",
            stderr
        );
    }
}

/// Test 3: Verify documentation structure and navigation files
#[test]
fn test_documentation_structure() {
    let root = project_root();
    let target_doc = root.join("target").join("doc");

    // Build documentation
    let output = Command::new("cargo")
        .arg("doc")
        .arg("--workspace")
        .arg("--no-deps")
        .current_dir(&root)
        .output()
        .expect("Failed to run cargo doc");

    assert!(
        output.status.success(),
        "cargo doc failed: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Verify each crate has an index.html
    let crates = vec!["axm_engine", "axm_cli", "axm_web"];
    for crate_name in &crates {
        let crate_index = target_doc.join(crate_name).join("index.html");
        assert!(
            crate_index.exists(),
            "index.html not found for {} at {:?}",
            crate_name,
            crate_index
        );

        // Verify index.html is not empty
        let content = fs::read_to_string(&crate_index)
            .unwrap_or_else(|_| panic!("Failed to read index.html for {}", crate_name));
        assert!(
            !content.is_empty(),
            "index.html for {} is empty",
            crate_name
        );
    }

    // Verify rustdoc standard files exist (search index handled below)
    let required_files = vec!["settings.html", "help.html"];

    for file in &required_files {
        let file_path = target_doc.join(file);
        assert!(
            file_path.exists(),
            "Required file {} not found at {:?}",
            file,
            file_path
        );
    }

    // Verify search index assets exist in either legacy or modern layout
    let search_assets = find_search_index_assets(&target_doc)
        .expect("Rustdoc search index assets not found in documentation output");
    assert!(
        search_assets.primary_path().exists(),
        "Primary search index asset missing at {:?}",
        search_assets.primary_path()
    );

    if let Some(content) = search_assets.primary_content() {
        assert!(
            !content.trim().is_empty(),
            "Primary search index asset at {:?} was unexpectedly empty",
            search_assets.primary_path()
        );
    }
}

/// Test 4: Verify custom index.html is generated correctly
#[test]
fn test_custom_index_generation() {
    let root = project_root();
    let target_doc = root.join("target").join("doc");

    // Build documentation
    let output = Command::new("cargo")
        .arg("doc")
        .arg("--workspace")
        .arg("--no-deps")
        .current_dir(&root)
        .output()
        .expect("Failed to run cargo doc");

    assert!(
        output.status.success(),
        "cargo doc failed before running generate-doc-index.sh:\n{}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Run generate-doc-index.sh script
    let script_path = root.join("scripts").join("generate-doc-index.sh");

    // Try to find bash executable on Windows
    #[cfg(windows)]
    let bash_cmd = {
        // Try common locations for Git Bash
        let possible_paths = [
            "C:\\Program Files\\Git\\bin\\bash.exe",
            "C:\\Program Files (x86)\\Git\\bin\\bash.exe",
            "bash", // Will work if Git Bash is in PATH
        ];

        possible_paths
            .iter()
            .find(|path| Command::new(path).arg("--version").output().is_ok())
            .map(|s| s.to_string())
    };

    #[cfg(unix)]
    let bash_cmd = "bash";

    // Skip test if bash is not available on Windows
    #[cfg(windows)]
    if bash_cmd.is_none() {
        eprintln!("Skipping test_custom_index_generation: bash not found on Windows");
        eprintln!("Install Git Bash or add bash to PATH to run this test");
        return;
    }

    #[cfg(windows)]
    let bash_executable = bash_cmd.unwrap();
    #[cfg(unix)]
    let bash_executable = bash_cmd;

    let output = Command::new(bash_executable)
        .arg(&script_path)
        .current_dir(&root)
        .output()
        .expect("Failed to run generate-doc-index.sh");

    if !output.status.success() {
        eprintln!("Script stderr: {}", String::from_utf8_lossy(&output.stderr));
        eprintln!("Script stdout: {}", String::from_utf8_lossy(&output.stdout));
        panic!(
            "generate-doc-index.sh failed with exit code: {:?}",
            output.status.code()
        );
    }

    // Verify custom index.html exists
    let index_html = target_doc.join("index.html");
    assert!(
        index_html.exists(),
        "Custom index.html not found at {:?}",
        index_html
    );

    // Verify custom index.html contains links to all crates
    let content = fs::read_to_string(&index_html).expect("Failed to read custom index.html");

    // Check which crates were actually built
    let expected_crates = vec!["axm_engine", "axm_cli", "axm_web"];
    let mut built_crates = Vec::new();

    for crate_name in &expected_crates {
        let crate_dir = target_doc.join(crate_name);
        if crate_dir.exists() {
            built_crates.push(*crate_name);
        }
    }

    // Verify links for all built crates exist in index.html
    for crate_name in &built_crates {
        let link = format!("{}/index.html", crate_name);
        assert!(
            content.contains(&link),
            "Custom index.html does not contain link to {} (crate was built at {:?})",
            crate_name,
            target_doc.join(crate_name)
        );
    }

    // Ensure at least axm_engine and axm_cli are built (axm_web depends on warp which is optional)
    assert!(
        built_crates.contains(&"axm_engine"),
        "axm_engine should be built"
    );
    assert!(built_crates.contains(&"axm_cli"), "axm_cli should be built");

    // Verify index.html contains project title
    assert!(
        content.contains("Axiomind"),
        "Custom index.html does not contain project title"
    );
}

/// Test 5: Verify cross-crate link examples in documentation
#[test]
fn test_cross_crate_link_examples() {
    let root = project_root();
    let target_doc = root.join("target").join("doc");

    // Build documentation
    let output = Command::new("cargo")
        .arg("doc")
        .arg("--workspace")
        .arg("--no-deps")
        .current_dir(&root)
        .output()
        .expect("Failed to run cargo doc");

    assert!(
        output.status.success(),
        "cargo doc failed before running generate-doc-index.sh:\n{}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Read axm_cli documentation to check for links to axm_engine types
    let cli_lib_path = target_doc.join("axm_cli").join("index.html");

    if cli_lib_path.exists() {
        let content = fs::read_to_string(&cli_lib_path).expect("Failed to read axm_cli index.html");

        assert!(
            content.contains("axm_cli"),
            "CLI documentation should reference its own crate name"
        );

        let has_explicit_link = content.contains("../axm_engine/");
        if !has_explicit_link {
            let search_assets = find_search_index_assets(&target_doc)
                .expect("Rustdoc search index assets not found when validating cross-crate links");
            assert!(
                search_assets.contains_crate("axm_engine"),
                "Cross-crate references from axm_cli to axm_engine were not detected in HTML or search index content"
            );
        }
    }
}
